/*! ieg-portal */
jQuery.easing.jswing = jQuery.easing.swing, jQuery.extend(jQuery.easing, {
		def: "easeOutQuad",
		swing: function(e, f, a, h, g) {
			return jQuery.easing[jQuery.easing.def](e, f, a, h, g)
		},
		easeInQuad: function(e, f, a, h, g) {
			return h * (f /= g) * f + a
		},
		easeOutQuad: function(e, f, a, h, g) {
			return -h * (f /= g) * (f - 2) + a
		},
		easeInOutQuad: function(e, f, a, h, g) {
			return(f /= g / 2) < 1 ? h / 2 * f * f + a : -h / 2 * (--f * (f - 2) - 1) + a
		},
		easeInCubic: function(e, f, a, h, g) {
			return h * (f /= g) * f * f + a
		},
		easeOutCubic: function(e, f, a, h, g) {
			return h * ((f = f / g - 1) * f * f + 1) + a
		},
		easeInOutCubic: function(e, f, a, h, g) {
			return(f /= g / 2) < 1 ? h / 2 * f * f * f + a : h / 2 * ((f -= 2) * f * f + 2) + a
		},
		easeInQuart: function(e, f, a, h, g) {
			return h * (f /= g) * f * f * f + a
		},
		easeOutQuart: function(e, f, a, h, g) {
			return -h * ((f = f / g - 1) * f * f * f - 1) + a
		},
		easeInOutQuart: function(e, f, a, h, g) {
			return(f /= g / 2) < 1 ? h / 2 * f * f * f * f + a : -h / 2 * ((f -= 2) * f * f * f - 2) + a
		},
		easeInQuint: function(e, f, a, h, g) {
			return h * (f /= g) * f * f * f * f + a
		},
		easeOutQuint: function(e, f, a, h, g) {
			return h * ((f = f / g - 1) * f * f * f * f + 1) + a
		},
		easeInOutQuint: function(e, f, a, h, g) {
			return(f /= g / 2) < 1 ? h / 2 * f * f * f * f * f + a : h / 2 * ((f -= 2) * f * f * f * f + 2) + a
		},
		easeInSine: function(e, f, a, h, g) {
			return -h * Math.cos(f / g * (Math.PI / 2)) + h + a
		},
		easeOutSine: function(e, f, a, h, g) {
			return h * Math.sin(f / g * (Math.PI / 2)) + a
		},
		easeInOutSine: function(e, f, a, h, g) {
			return -h / 2 * (Math.cos(Math.PI * f / g) - 1) + a
		},
		easeInExpo: function(e, f, a, h, g) {
			return 0 == f ? a : h * Math.pow(2, 10 * (f / g - 1)) + a
		},
		easeOutExpo: function(e, f, a, h, g) {
			return f == g ? a + h : h * (-Math.pow(2, -10 * f / g) + 1) + a
		},
		easeInOutExpo: function(e, f, a, h, g) {
			return 0 == f ? a : f == g ? a + h : (f /= g / 2) < 1 ? h / 2 * Math.pow(2, 10 * (f - 1)) + a : h / 2 * (-Math.pow(2, -10 * --f) + 2) + a
		},
		easeInCirc: function(e, f, a, h, g) {
			return -h * (Math.sqrt(1 - (f /= g) * f) - 1) + a
		},
		easeOutCirc: function(e, f, a, h, g) {
			return h * Math.sqrt(1 - (f = f / g - 1) * f) + a
		},
		easeInOutCirc: function(e, f, a, h, g) {
			return(f /= g / 2) < 1 ? -h / 2 * (Math.sqrt(1 - f * f) - 1) + a : h / 2 * (Math.sqrt(1 - (f -= 2) * f) + 1) + a
		},
		easeInElastic: function(f, h, e, l, k) {
			var i = 1.70158,
				j = 0,
				g = l;
			if(0 == h) return e;
			if(1 == (h /= k)) return e + l;
			if(j || (j = .3 * k), g < Math.abs(l)) {
				g = l;
				var i = j / 4
			} else var i = j / (2 * Math.PI) * Math.asin(l / g);
			return -(g * Math.pow(2, 10 * (h -= 1)) * Math.sin(2 * (h * k - i) * Math.PI / j)) + e
		},
		easeOutElastic: function(f, h, e, l, k) {
			var i = 1.70158,
				j = 0,
				g = l;
			if(0 == h) return e;
			if(1 == (h /= k)) return e + l;
			if(j || (j = .3 * k), g < Math.abs(l)) {
				g = l;
				var i = j / 4
			} else var i = j / (2 * Math.PI) * Math.asin(l / g);
			return g * Math.pow(2, -10 * h) * Math.sin(2 * (h * k - i) * Math.PI / j) + l + e
		},
		easeInOutElastic: function(f, h, e, l, k) {
			var i = 1.70158,
				j = 0,
				g = l;
			if(0 == h) return e;
			if(2 == (h /= k / 2)) return e + l;
			if(j || (j = .3 * k * 1.5), g < Math.abs(l)) {
				g = l;
				var i = j / 4
			} else var i = j / (2 * Math.PI) * Math.asin(l / g);
			return 1 > h ? -.5 * g * Math.pow(2, 10 * (h -= 1)) * Math.sin(2 * (h * k - i) * Math.PI / j) + e : g * Math.pow(2, -10 * (h -= 1)) * Math.sin(2 * (h * k - i) * Math.PI / j) * .5 + l + e
		},
		easeInBack: function(e, f, a, i, h, g) {
			return void 0 == g && (g = 1.70158), i * (f /= h) * f * ((g + 1) * f - g) + a
		},
		easeOutBack: function(e, f, a, i, h, g) {
			return void 0 == g && (g = 1.70158), i * ((f = f / h - 1) * f * ((g + 1) * f + g) + 1) + a
		},
		easeInOutBack: function(e, f, a, i, h, g) {
			return void 0 == g && (g = 1.70158), (f /= h / 2) < 1 ? i / 2 * f * f * (((g *= 1.525) + 1) * f - g) + a : i / 2 * ((f -= 2) * f * (((g *= 1.525) + 1) * f + g) + 2) + a
		},
		easeInBounce: function(e, f, a, h, g) {
			return h - jQuery.easing.easeOutBounce(e, g - f, 0, h, g) + a
		},
		easeOutBounce: function(e, f, a, h, g) {
			return(f /= g) < 1 / 2.75 ? 7.5625 * h * f * f + a : 2 / 2.75 > f ? h * (7.5625 * (f -= 1.5 / 2.75) * f + .75) + a : 2.5 / 2.75 > f ? h * (7.5625 * (f -= 2.25 / 2.75) * f + .9375) + a : h * (7.5625 * (f -= 2.625 / 2.75) * f + .984375) + a
		},
		easeInOutBounce: function(e, f, a, h, g) {
			return g / 2 > f ? .5 * jQuery.easing.easeInBounce(e, 2 * f, 0, h, g) + a : .5 * jQuery.easing.easeOutBounce(e, 2 * f - g, 0, h, g) + .5 * h + a
		}
	}),
	function(factory) {
		"function" == typeof define && define.amd ? define(["jquery"], factory) : "object" == typeof exports ? module.exports = factory : factory(jQuery)
	}(function($) {
		function handler(event) {
			var orgEvent = event || window.event,
				args = slice.call(arguments, 1),
				delta = 0,
				deltaX = 0,
				deltaY = 0,
				absDelta = 0,
				offsetX = 0,
				offsetY = 0;
			if(event = $.event.fix(orgEvent), event.type = "mousewheel", "detail" in orgEvent && (deltaY = -1 * orgEvent.detail), "wheelDelta" in orgEvent && (deltaY = orgEvent.wheelDelta), "wheelDeltaY" in orgEvent && (deltaY = orgEvent.wheelDeltaY), "wheelDeltaX" in orgEvent && (deltaX = -1 * orgEvent.wheelDeltaX), "axis" in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS && (deltaX = -1 * deltaY, deltaY = 0), delta = 0 === deltaY ? deltaX : deltaY, "deltaY" in orgEvent && (deltaY = -1 * orgEvent.deltaY, delta = deltaY), "deltaX" in orgEvent && (deltaX = orgEvent.deltaX, 0 === deltaY && (delta = -1 * deltaX)), 0 !== deltaY || 0 !== deltaX) {
				if(1 === orgEvent.deltaMode) {
					var lineHeight = $.data(this, "mousewheel-line-height");
					delta *= lineHeight, deltaY *= lineHeight, deltaX *= lineHeight
				} else if(2 === orgEvent.deltaMode) {
					var pageHeight = $.data(this, "mousewheel-page-height");
					delta *= pageHeight, deltaY *= pageHeight, deltaX *= pageHeight
				}
				if(absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX)), (!lowestDelta || lowestDelta > absDelta) && (lowestDelta = absDelta, shouldAdjustOldDeltas(orgEvent, absDelta) && (lowestDelta /= 40)), shouldAdjustOldDeltas(orgEvent, absDelta) && (delta /= 40, deltaX /= 40, deltaY /= 40), delta = Math[delta >= 1 ? "floor" : "ceil"](delta / lowestDelta), deltaX = Math[deltaX >= 1 ? "floor" : "ceil"](deltaX / lowestDelta), deltaY = Math[deltaY >= 1 ? "floor" : "ceil"](deltaY / lowestDelta), special.settings.normalizeOffset && this.getBoundingClientRect) {
					var boundingRect = this.getBoundingClientRect();
					offsetX = event.clientX - boundingRect.left, offsetY = event.clientY - boundingRect.top
				}
				return event.deltaX = deltaX, event.deltaY = deltaY, event.deltaFactor = lowestDelta, event.offsetX = offsetX, event.offsetY = offsetY, event.deltaMode = 0, args.unshift(event, delta, deltaX, deltaY), nullLowestDeltaTimeout && clearTimeout(nullLowestDeltaTimeout), nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200), ($.event.dispatch || $.event.handle).apply(this, args)
			}
		}

		function nullLowestDelta() {
			lowestDelta = null
		}

		function shouldAdjustOldDeltas(orgEvent, absDelta) {
			return special.settings.adjustOldDeltas && "mousewheel" === orgEvent.type && absDelta % 120 === 0
		}
		var nullLowestDeltaTimeout, lowestDelta, toFix = ["wheel", "mousewheel", "DOMMouseScroll", "MozMousePixelScroll"],
			toBind = "onwheel" in document || document.documentMode >= 9 ? ["wheel"] : ["mousewheel", "DomMouseScroll", "MozMousePixelScroll"],
			slice = Array.prototype.slice;
		if($.event.fixHooks)
			for(var i = toFix.length; i;) $.event.fixHooks[toFix[--i]] = $.event.mouseHooks;
		var special = $.event.special.mousewheel = {
			version: "3.1.11",
			setup: function() {
				if(this.addEventListener)
					for(var i = toBind.length; i;) this.addEventListener(toBind[--i], handler, !1);
				else this.onmousewheel = handler;
				$.data(this, "mousewheel-line-height", special.getLineHeight(this)), $.data(this, "mousewheel-page-height", special.getPageHeight(this))
			},
			teardown: function() {
				if(this.removeEventListener)
					for(var i = toBind.length; i;) this.removeEventListener(toBind[--i], handler, !1);
				else this.onmousewheel = null;
				$.removeData(this, "mousewheel-line-height"), $.removeData(this, "mousewheel-page-height")
			},
			getLineHeight: function(elem) {
				var $parent = $(elem)["offsetParent" in $.fn ? "offsetParent" : "parent"]();
				return $parent.length || ($parent = $("body")), parseInt($parent.css("fontSize"), 10)
			},
			getPageHeight: function(elem) {
				return $(elem).height()
			},
			settings: {
				adjustOldDeltas: !0,
				normalizeOffset: !0
			}
		};
		$.fn.extend({
			mousewheel: function(fn) {
				return fn ? this.bind("mousewheel", fn) : this.trigger("mousewheel")
			},
			unmousewheel: function(fn) {
				return this.unbind("mousewheel", fn)
			}
		})
	}),
	function($) {
		"use strict";
		var has3d, vendor = "",
			PI = Math.PI,
			A90 = PI / 2,
			isTouch = "ontouchstart" in window,
			events = isTouch ? {
				start: "touchstart",
				move: "touchmove",
				end: "touchend"
			} : {
				start: "mousedown",
				move: "mousemove",
				end: "mouseup"
			},
			corners = {
				backward: ["bl", "tl"],
				forward: ["br", "tr"],
				all: ["tl", "bl", "tr", "br"]
			},
			displays = ["single", "double"],
			turnOptions = {
				page: 1,
				gradients: !0,
				duration: 600,
				acceleration: !0,
				display: "double",
				when: null
			},
			flipOptions = {
				folding: null,
				corners: "forward",
				cornerSize: 100,
				gradients: !0,
				duration: 600,
				acceleration: !0
			},
			pagesInDOM = 6,
			pagePosition = {
				0: {
					top: 0,
					left: 0,
					right: "auto",
					bottom: "auto"
				},
				1: {
					top: 0,
					right: 0,
					left: "auto",
					bottom: "auto"
				}
			},
			divAtt = function(top, left, zIndex, overf) {
				return {
					css: {
						position: "absolute",
						top: top,
						left: left,
						overflow: overf || "hidden",
						"z-index": zIndex || "auto"
					}
				}
			},
			bezier = function(p1, p2, p3, p4, t) {
				var mum1 = 1 - t,
					mum13 = mum1 * mum1 * mum1,
					mu3 = t * t * t;
				return point2D(Math.round(mum13 * p1.x + 3 * t * mum1 * mum1 * p2.x + 3 * t * t * mum1 * p3.x + mu3 * p4.x), Math.round(mum13 * p1.y + 3 * t * mum1 * mum1 * p2.y + 3 * t * t * mum1 * p3.y + mu3 * p4.y))
			},
			deg = function(radians) {
				return radians / PI * 180
			},
			point2D = function(x, y) {
				return {
					x: x,
					y: y
				}
			},
			translate = function(x, y, use3d) {
				return has3d && use3d ? " translate3d(" + x + "px," + y + "px, 0px) " : " translate(" + x + "px, " + y + "px) "
			},
			rotate = function(degrees) {
				return " rotate(" + degrees + "deg) "
			},
			has = function(property, object) {
				return Object.prototype.hasOwnProperty.call(object, property)
			},
			getPrefix = function() {
				for(var vendorPrefixes = ["Moz", "Webkit", "Khtml", "O", "ms"], len = vendorPrefixes.length, vendor = ""; len--;) vendorPrefixes[len] + "Transform" in document.body.style && (vendor = "-" + vendorPrefixes[len].toLowerCase() + "-");
				return vendor
			},
			gradient = function(obj, p0, p1, colors, numColors) {
				var j, cols = [];
				if("-webkit-" == vendor) {
					for(j = 0; numColors > j; j++) cols.push("color-stop(" + colors[j][0] + ", " + colors[j][1] + ")");
					obj.css({
						"background-image": "-webkit-gradient(linear, " + p0.x + "% " + p0.y + "%,  " + p1.x + "% " + p1.y + "%, " + cols.join(",") + " )"
					})
				} else {
					p0 = {
						x: p0.x / 100 * obj.width(),
						y: p0.y / 100 * obj.height()
					}, p1 = {
						x: p1.x / 100 * obj.width(),
						y: p1.y / 100 * obj.height()
					};
					var dx = p1.x - p0.x,
						dy = p1.y - p0.y,
						angle = Math.atan2(dy, dx),
						angle2 = angle - Math.PI / 2,
						diagonal = Math.abs(obj.width() * Math.sin(angle2)) + Math.abs(obj.height() * Math.cos(angle2)),
						gradientDiagonal = Math.sqrt(dy * dy + dx * dx),
						corner = point2D(p1.x < p0.x ? obj.width() : 0, p1.y < p0.y ? obj.height() : 0),
						slope = Math.tan(angle),
						inverse = -1 / slope,
						x = (inverse * corner.x - corner.y - slope * p0.x + p0.y) / (inverse - slope),
						c = {
							x: x,
							y: inverse * x - inverse * corner.x + corner.y
						},
						segA = Math.sqrt(Math.pow(c.x - p0.x, 2) + Math.pow(c.y - p0.y, 2));
					for(j = 0; numColors > j; j++) cols.push(" " + colors[j][1] + " " + 100 * (segA + gradientDiagonal * colors[j][0]) / diagonal + "%");
					obj.css({
						"background-image": vendor + "linear-gradient(" + -angle + "rad," + cols.join(",") + ")"
					})
				}
			},
			turnMethods = {
				init: function(opts) {
					void 0 === has3d && (has3d = "WebKitCSSMatrix" in window || "MozPerspective" in document.body.style, vendor = getPrefix());
					var i, data = this.data(),
						ch = this.children();
					if(opts = $.extend({
							width: this.width(),
							height: this.height()
						}, turnOptions, opts), data.opts = opts, data.pageObjs = {}, data.pages = {}, data.pageWrap = {}, data.pagePlace = {}, data.pageMv = [], data.totalPages = opts.pages || 0, opts.when)
						for(i in opts.when) has(i, opts.when) && this.bind(i, opts.when[i]);
					for(this.css({
							position: "relative",
							width: opts.width,
							height: opts.height
						}), this.turn("display", opts.display), has3d && !isTouch && opts.acceleration && this.transform(translate(0, 0, !0)), i = 0; i < ch.length; i++) this.turn("addPage", ch[i], i + 1);
					return this.turn("page", opts.page), corners = $.extend({}, corners, opts.corners), $(this).bind(events.start, function(e) {
						for(var page in data.pages)
							if(has(page, data.pages) && flipMethods._eventStart.call(data.pages[page], e) === !1) return !1
					}), $(document).bind(events.move, function(e) {
						for(var page in data.pages) has(page, data.pages) && flipMethods._eventMove.call(data.pages[page], e)
					}).bind(events.end, function(e) {
						for(var page in data.pages) has(page, data.pages) && flipMethods._eventEnd.call(data.pages[page], e)
					}), data.done = !0, this
				},
				addPage: function(element, page) {
					var incPages = !1,
						data = this.data(),
						lastPage = data.totalPages + 1;
					if(page) {
						if(page == lastPage) page = lastPage, incPages = !0;
						else if(page > lastPage) throw new Error('It is impossible to add the page "' + page + '", the maximum value is: "' + lastPage + '"')
					} else page = lastPage, incPages = !0;
					return page >= 1 && lastPage >= page && (data.done && this.turn("stop"), page in data.pageObjs && turnMethods._movePages.call(this, page, 1), incPages && (data.totalPages = lastPage), data.pageObjs[page] = $(element).addClass("turn-page p" + page), turnMethods._addPage.call(this, page), data.done && this.turn("update"), turnMethods._removeFromDOM.call(this)), this
				},
				_addPage: function(page) {
					var data = this.data(),
						element = data.pageObjs[page];
					if(element)
						if(turnMethods._necessPage.call(this, page)) {
							if(!data.pageWrap[page]) {
								var pageWidth = "double" == data.display ? this.width() / 2 : this.width(),
									pageHeight = this.height();
								element.css({
									width: pageWidth,
									height: pageHeight
								}), data.pagePlace[page] = page, data.pageWrap[page] = $("<div/>", {
									"class": "turn-page-wrapper",
									page: page,
									css: {
										position: "absolute",
										overflow: "hidden",
										width: pageWidth,
										height: pageHeight
									}
								}).css(pagePosition["double" == data.display ? page % 2 : 0]), this.append(data.pageWrap[page]), data.pageWrap[page].prepend(data.pageObjs[page])
							}
							page && 1 != turnMethods._setPageLoc.call(this, page) || turnMethods._makeFlip.call(this, page)
						} else data.pagePlace[page] = 0, data.pageObjs[page] && data.pageObjs[page].remove()
				},
				hasPage: function(page) {
					return page in this.data().pageObjs
				},
				_makeFlip: function(page) {
					var data = this.data();
					if(!data.pages[page] && data.pagePlace[page] == page) {
						var single = "single" == data.display,
							even = page % 2;
						data.pages[page] = data.pageObjs[page].css({
							width: single ? this.width() : this.width() / 2,
							height: this.height()
						}).flip({
							page: page,
							next: single && page === data.totalPages ? page - 1 : even || single ? page + 1 : page - 1,
							turn: this,
							duration: data.opts.duration,
							acceleration: data.opts.acceleration,
							corners: single ? "all" : even ? "forward" : "backward",
							backGradient: data.opts.gradients,
							frontGradient: data.opts.gradients
						}).flip("disable", data.disabled).bind("pressed", turnMethods._pressed).bind("released", turnMethods._released).bind("start", turnMethods._start).bind("end", turnMethods._end).bind("flip", turnMethods._flip)
					}
					return data.pages[page]
				},
				_makeRange: function() {
					var page, range = (this.data(), this.turn("range"));
					for(page = range[0]; page <= range[1]; page++) turnMethods._addPage.call(this, page)
				},
				range: function(page) {
					var remainingPages, left, right, data = this.data();
					page = page || data.tpage || data.page;
					var view = turnMethods._view.call(this, page);
					if(1 > page || page > data.totalPages) throw new Error('"' + page + '" is not a page for range');
					return view[1] = view[1] || view[0], view[0] >= 1 && view[1] <= data.totalPages ? (remainingPages = Math.floor((pagesInDOM - 2) / 2), data.totalPages - view[1] > view[0] ? (left = Math.min(view[0] - 1, remainingPages), right = 2 * remainingPages - left) : (right = Math.min(data.totalPages - view[1], remainingPages), left = 2 * remainingPages - right)) : (left = pagesInDOM - 1, right = pagesInDOM - 1), [Math.max(1, view[0] - left), Math.min(data.totalPages, view[1] + right)]
				},
				_necessPage: function(page) {
					if(0 === page) return !0;
					var range = this.turn("range");
					return page >= range[0] && page <= range[1]
				},
				_removeFromDOM: function() {
					var page, data = this.data();
					for(page in data.pageWrap) has(page, data.pageWrap) && !turnMethods._necessPage.call(this, page) && turnMethods._removePageFromDOM.call(this, page)
				},
				_removePageFromDOM: function(page) {
					var data = this.data();
					if(data.pages[page]) {
						var dd = data.pages[page].data();
						dd.f && dd.f.fwrapper && dd.f.fwrapper.remove(), data.pages[page].remove(), delete data.pages[page]
					}
					data.pageObjs[page] && data.pageObjs[page].remove(), data.pageWrap[page] && (data.pageWrap[page].remove(), delete data.pageWrap[page]), delete data.pagePlace[page]
				},
				removePage: function(page) {
					var data = this.data();
					return data.pageObjs[page] && (this.turn("stop"), turnMethods._removePageFromDOM.call(this, page), delete data.pageObjs[page], turnMethods._movePages.call(this, page, -1), data.totalPages = data.totalPages - 1, turnMethods._makeRange.call(this), data.page > data.totalPages && this.turn("page", data.totalPages)), this
				},
				_movePages: function(from, change) {
					var page, data = this.data(),
						single = "single" == data.display,
						move = function(page) {
							var next = page + change,
								odd = next % 2;
							data.pageObjs[page] && (data.pageObjs[next] = data.pageObjs[page].removeClass("page" + page).addClass("page" + next)), data.pagePlace[page] && data.pageWrap[page] && (data.pagePlace[next] = next, data.pageWrap[next] = data.pageWrap[page].css(pagePosition[single ? 0 : odd]).attr("page", next), data.pages[page] && (data.pages[next] = data.pages[page].flip("options", {
								page: next,
								next: single || odd ? next + 1 : next - 1,
								corners: single ? "all" : odd ? "forward" : "backward"
							})), change && (delete data.pages[page], delete data.pagePlace[page], delete data.pageObjs[page], delete data.pageWrap[page], delete data.pageObjs[page]))
						};
					if(change > 0)
						for(page = data.totalPages; page >= from; page--) move(page);
					else
						for(page = from; page <= data.totalPages; page++) move(page)
				},
				display: function(display) {
					var data = this.data(),
						currentDisplay = data.display;
					if(display) {
						if(-1 == $.inArray(display, displays)) throw new Error('"' + display + '" is not a value for display');
						if("single" == display ? data.pageObjs[0] || (this.turn("stop").css({
								overflow: "hidden"
							}), data.pageObjs[0] = $("<div />", {
								"class": "turn-page p-temporal"
							}).css({
								width: this.width(),
								height: this.height()
							}).appendTo(this)) : data.pageObjs[0] && (this.turn("stop").css({
								overflow: ""
							}), data.pageObjs[0].remove(), delete data.pageObjs[0]), data.display = display, currentDisplay) {
							var size = this.turn("size");
							turnMethods._movePages.call(this, 1, 0), this.turn("size", size.width, size.height).turn("update")
						}
						return this
					}
					return currentDisplay
				},
				animating: function() {
					return this.data().pageMv.length > 0
				},
				disable: function(bool) {
					var page, data = this.data(),
						view = this.turn("view");
					data.disabled = void 0 === bool || bool === !0;
					for(page in data.pages) has(page, data.pages) && data.pages[page].flip("disable", bool ? $.inArray(page, view) : !1);
					return this
				},
				size: function(width, height) {
					if(width && height) {
						var page, data = this.data(),
							pageWidth = "double" == data.display ? width / 2 : width;
						this.css({
							width: width,
							height: height
						}), data.pageObjs[0] && data.pageObjs[0].css({
							width: pageWidth,
							height: height
						});
						for(page in data.pageWrap) has(page, data.pageWrap) && (data.pageObjs[page].css({
							width: pageWidth,
							height: height
						}), data.pageWrap[page].css({
							width: pageWidth,
							height: height
						}), data.pages[page] && data.pages[page].css({
							width: pageWidth,
							height: height
						}));
						return this.turn("resize"), this
					}
					return {
						width: this.width(),
						height: this.height()
					}
				},
				resize: function() {
					var page, data = this.data();
					for(data.pages[0] && (data.pageWrap[0].css({
							left: -this.width()
						}), data.pages[0].flip("resize", !0)), page = 1; page <= data.totalPages; page++) data.pages[page] && data.pages[page].flip("resize", !0)
				},
				_removeMv: function(page) {
					var i, data = this.data();
					for(i = 0; i < data.pageMv.length; i++)
						if(data.pageMv[i] == page) return data.pageMv.splice(i, 1), !0;
					return !1
				},
				_addMv: function(page) {
					var data = this.data();
					turnMethods._removeMv.call(this, page), data.pageMv.push(page)
				},
				_view: function(page) {
					var data = this.data();
					return page = page || data.page, "double" == data.display ? page % 2 ? [page - 1, page] : [page, page + 1] : [page]
				},
				view: function(page) {
					var data = this.data(),
						view = turnMethods._view.call(this, page);
					return "double" == data.display ? [view[0] > 0 ? view[0] : 0, view[1] <= data.totalPages ? view[1] : 0] : [view[0] > 0 && view[0] <= data.totalPages ? view[0] : 0]
				},
				stop: function() {
					var i, opts, data = this.data(),
						pages = data.pageMv;
					data.pageMv = [], data.tpage && (data.page = data.tpage, delete data.tpage);
					for(i in pages) has(i, pages) && (opts = data.pages[pages[i]].data().f.opts, flipMethods._moveFoldingPage.call(data.pages[pages[i]], null), data.pages[pages[i]].flip("hideFoldedPage"), data.pagePlace[opts.next] = opts.next, opts.force && (opts.next = opts.page % 2 === 0 ? opts.page - 1 : opts.page + 1, delete opts.force));
					return this.turn("update"), this
				},
				pages: function(pages) {
					var data = this.data();
					if(pages) {
						if(pages < data.totalPages) {
							for(var page = pages + 1; page <= data.totalPages; page++) this.turn("removePage", page);
							this.turn("page") > pages && this.turn("page", pages)
						}
						return data.totalPages = pages, this
					}
					return data.totalPages
				},
				_fitPage: function(page, ok) {
					var data = this.data(),
						newView = this.turn("view", page);
					data.page != page && (this.trigger("turning", [page, newView]), -1 != $.inArray(1, newView) && this.trigger("first"), -1 != $.inArray(data.totalPages, newView) && this.trigger("last")), data.pageObjs[page] && (data.tpage = page, this.turn("stop", ok), turnMethods._removeFromDOM.call(this), turnMethods._makeRange.call(this), this.trigger("turned", [page, newView]))
				},
				_turnPage: function(page) {
					var current, next, data = this.data(),
						view = this.turn("view"),
						newView = this.turn("view", page);
					if(data.page != page && (this.trigger("turning", [page, newView]), -1 != $.inArray(1, newView) && this.trigger("first"), -1 != $.inArray(data.totalPages, newView) && this.trigger("last")), data.pageObjs[page] && (data.tpage = page, this.turn("stop"), turnMethods._makeRange.call(this), "single" == data.display ? (current = view[0], next = newView[0]) : view[1] && page > view[1] ? (current = view[1], next = newView[0]) : view[0] && page < view[0] && (current = view[0], next = newView[1]), data.pages[current])) {
						var opts = data.pages[current].data().f.opts;
						data.tpage = next, opts.next != next && (opts.next = next, data.pagePlace[next] = opts.page, opts.force = !0), "single" == data.display ? data.pages[current].flip("turnPage", newView[0] > view[0] ? "br" : "bl") : data.pages[current].flip("turnPage")
					}
				},
				page: function(page) {
					page = parseInt(page, 10);
					var data = this.data();
					return page > 0 && page <= data.totalPages ? (data.done && -1 == $.inArray(page, this.turn("view")) ? turnMethods._turnPage.call(this, page) : turnMethods._fitPage.call(this, page), this) : data.page
				},
				next: function() {
					var data = this.data();
					return this.turn("page", turnMethods._view.call(this, data.page).pop() + 1)
				},
				previous: function() {
					var data = this.data();
					return this.turn("page", turnMethods._view.call(this, data.page).shift() - 1)
				},
				_addMotionPage: function() {
					var opts = $(this).data().f.opts,
						turn = opts.turn,
						dd = turn.data();
					opts.pageMv = opts.page, turnMethods._addMv.call(turn, opts.pageMv), dd.pagePlace[opts.next] = opts.page, turn.turn("update")
				},
				_start: function(e, opts, corner) {
					var data = opts.turn.data(),
						event = $.Event("start");
					if(e.stopPropagation(), opts.turn.trigger(event, [opts, corner]), event.isDefaultPrevented()) return void e.preventDefault();
					if("single" == data.display) {
						var left = "l" == corner.charAt(1);
						1 == opts.page && left || opts.page == data.totalPages && !left ? e.preventDefault() : left ? (opts.next = opts.next < opts.page ? opts.next : opts.page - 1, opts.force = !0) : opts.next = opts.next > opts.page ? opts.next : opts.page + 1
					}
					turnMethods._addMotionPage.call(this)
				},
				_end: function(e, turned) {
					var that = $(this),
						data = that.data().f,
						opts = data.opts,
						turn = opts.turn,
						dd = turn.data();
					e.stopPropagation(), turned || dd.tpage ? (dd.tpage == opts.next || dd.tpage == opts.page) && (delete dd.tpage, turnMethods._fitPage.call(turn, dd.tpage || opts.next, !0)) : (turnMethods._removeMv.call(turn, opts.pageMv), turn.turn("update"))
				},
				_pressed: function() {
					var page, that = $(this),
						data = that.data().f,
						turn = data.opts.turn,
						pages = turn.data().pages;
					for(page in pages) page != data.opts.page && pages[page].flip("disable", !0);
					return data.time = (new Date).getTime()
				},
				_released: function(e, point) {
					var that = $(this),
						data = that.data().f;
					e.stopPropagation(), ((new Date).getTime() - data.time < 200 || point.x < 0 || point.x > $(this).width()) && (e.preventDefault(), data.opts.turn.data().tpage = data.opts.next, data.opts.turn.turn("update"), $(that).flip("turnPage"))
				},
				_flip: function() {
					var opts = $(this).data().f.opts;
					opts.turn.trigger("turn", [opts.next])
				},
				calculateZ: function(mv) {
					var i, page, nextPage, placePage, dpage, that = this,
						data = this.data(),
						view = this.turn("view"),
						currentPage = view[0] || view[1],
						r = {
							pageZ: {},
							partZ: {},
							pageV: {}
						},
						addView = function(page) {
							var view = that.turn("view", page);
							view[0] && (r.pageV[view[0]] = !0), view[1] && (r.pageV[view[1]] = !0)
						};
					for(i = 0; i < mv.length; i++) page = mv[i], nextPage = data.pages[page].data().f.opts.next, placePage = data.pagePlace[page], addView(page), addView(nextPage), dpage = data.pagePlace[nextPage] == nextPage ? nextPage : page, r.pageZ[dpage] = data.totalPages - Math.abs(currentPage - dpage), r.partZ[placePage] = 2 * data.totalPages + Math.abs(currentPage - dpage);
					return r
				},
				update: function() {
					var page, data = this.data();
					if(data.pageMv.length && 0 !== data.pageMv[0]) {
						var apage, pos = this.turn("calculateZ", data.pageMv),
							view = this.turn("view", data.tpage);
						data.pagePlace[view[0]] == view[0] ? apage = view[0] : data.pagePlace[view[1]] == view[1] && (apage = view[1]);
						for(page in data.pageWrap) has(page, data.pageWrap) && (data.pageWrap[page].css({
							display: pos.pageV[page] ? "" : "none",
							"z-index": pos.pageZ[page] || 0
						}), data.pages[page] && (data.pages[page].flip("z", pos.partZ[page] || null), pos.pageV[page] && data.pages[page].flip("resize"), data.tpage && data.pages[page].flip("disable", !0)))
					} else
						for(page in data.pageWrap)
							if(has(page, data.pageWrap)) {
								var pageLocation = turnMethods._setPageLoc.call(this, page);
								data.pages[page] && data.pages[page].flip("disable", data.disabled || 1 != pageLocation).flip("z", null)
							}
				},
				_setPageLoc: function(page) {
					var data = this.data(),
						view = this.turn("view");
					return page == view[0] || page == view[1] ? (data.pageWrap[page].css({
						"z-index": data.totalPages,
						display: ""
					}), 1) : "single" == data.display && page == view[0] + 1 || "double" == data.display && page == view[0] - 2 || page == view[1] + 2 ? (data.pageWrap[page].css({
						"z-index": data.totalPages - 1,
						display: ""
					}), 2) : (data.pageWrap[page].css({
						"z-index": 0,
						display: "none"
					}), 0)
				}
			},
			flipMethods = {
				init: function(opts) {
					return opts.gradients && (opts.frontGradient = !0, opts.backGradient = !0), this.data({
						f: {}
					}), this.flip("options", opts), flipMethods._addPageWrapper.call(this), this
				},
				setData: function(d) {
					var data = this.data();
					return data.f = $.extend(data.f, d), this
				},
				options: function(opts) {
					var data = this.data().f;
					return opts ? (flipMethods.setData.call(this, {
						opts: $.extend({}, data.opts || flipOptions, opts)
					}), this) : data.opts
				},
				z: function(z) {
					var data = this.data().f;
					return data.opts["z-index"] = z, data.fwrapper.css({
						"z-index": z || parseInt(data.parent.css("z-index"), 10) || 0
					}), this
				},
				_cAllowed: function() {
					return corners[this.data().f.opts.corners] || this.data().f.opts.corners
				},
				_cornerActivated: function(e) {
					if(void 0 === e.originalEvent) return !1;
					e = isTouch ? e.originalEvent.touches : [e];
					var data = this.data().f,
						pos = data.parent.offset(),
						width = this.width(),
						height = this.height(),
						c = {
							x: Math.max(0, e[0].pageX - pos.left),
							y: Math.max(0, e[0].pageY - pos.top)
						},
						csz = data.opts.cornerSize,
						allowedCorners = flipMethods._cAllowed.call(this);
					if(c.x <= 0 || c.y <= 0 || c.x >= width || c.y >= height) return !1;
					if(c.y < csz) c.corner = "t";
					else {
						if(!(c.y >= height - csz)) return !1;
						c.corner = "b"
					}
					if(c.x <= csz) c.corner += "l";
					else {
						if(!(c.x >= width - csz)) return !1;
						c.corner += "r"
					}
					return -1 == $.inArray(c.corner, allowedCorners) ? !1 : c
				},
				_c: function(corner, opts) {
					return opts = opts || 0, {
						tl: point2D(opts, opts),
						tr: point2D(this.width() - opts, opts),
						bl: point2D(opts, this.height() - opts),
						br: point2D(this.width() - opts, this.height() - opts)
					}[corner]
				},
				_c2: function(corner) {
					return {
						tl: point2D(2 * this.width(), 0),
						tr: point2D(-this.width(), 0),
						bl: point2D(2 * this.width(), this.height()),
						br: point2D(-this.width(), this.height())
					}[corner]
				},
				_foldingPage: function() {
					var opts = this.data().f.opts;
					if(opts.folding) return opts.folding;
					if(opts.turn) {
						var data = opts.turn.data();
						return "single" == data.display ? data.pageObjs[opts.next] ? data.pageObjs[0] : null : data.pageObjs[opts.next]
					}
				},
				_backGradient: function() {
					var data = this.data().f,
						turn = data.opts.turn,
						gradient = data.opts.backGradient && (!turn || "single" == turn.data().display || 2 != data.opts.page && data.opts.page != turn.data().totalPages - 1);
					return gradient && !data.bshadow && (data.bshadow = $("<div/>", divAtt(0, 0, 1)).css({
						position: "",
						width: this.width(),
						height: this.height()
					}).appendTo(data.parent)), gradient
				},
				resize: function(full) {
					var data = this.data().f,
						width = this.width(),
						height = this.height(),
						size = Math.round(Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2)));
					full && (data.wrapper.css({
						width: size,
						height: size
					}), data.fwrapper.css({
						width: size,
						height: size
					}).children(":first-child").css({
						width: width,
						height: height
					}), data.fpage.css({
						width: height,
						height: width
					}), data.opts.frontGradient && data.ashadow.css({
						width: height,
						height: width
					}), flipMethods._backGradient.call(this) && data.bshadow.css({
						width: width,
						height: height
					})), data.parent.is(":visible") && (data.fwrapper.css({
						top: data.parent.offset().top,
						left: data.parent.offset().left
					}), data.opts.turn && data.fparent.css({
						top: -data.opts.turn.offset().top,
						left: -data.opts.turn.offset().left
					})), this.flip("z", data.opts["z-index"])
				},
				_addPageWrapper: function() {
					var data = this.data().f,
						parent = this.parent();
					if(!data.wrapper) {
						{
							var width = (this.css("left"), this.css("top"), this.width()),
								height = this.height();
							Math.round(Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2)))
						}
						if(data.parent = parent, data.fparent = data.opts.turn ? data.opts.turn.data().fparent : $("#turn-fwrappers"), !data.fparent) {
							var fparent = $("<div/>", {
								css: {
									"pointer-events": "none"
								}
							}).hide();
							fparent.data().flips = 0, data.opts.turn ? (fparent.css(divAtt(-data.opts.turn.offset().top, -data.opts.turn.offset().left, "auto", "visible").css).appendTo(data.opts.turn), data.opts.turn.data().fparent = fparent) : fparent.css(divAtt(0, 0, "auto", "visible").css).attr("id", "turn-fwrappers").appendTo($("body")), data.fparent = fparent
						}
						this.css({
							position: "absolute",
							top: 0,
							left: 0,
							bottom: "auto",
							right: "auto"
						}), data.wrapper = $("<div/>", divAtt(0, 0, this.css("z-index"))).appendTo(parent).prepend(this), data.fwrapper = $("<div/>", divAtt(parent.offset().top, parent.offset().left)).hide().appendTo(data.fparent), data.fpage = $("<div/>", {
							css: {
								cursor: "default"
							}
						}).appendTo($("<div/>", divAtt(0, 0, 0, "visible")).appendTo(data.fwrapper)), data.opts.frontGradient && (data.ashadow = $("<div/>", divAtt(0, 0, 1)).appendTo(data.fpage)), flipMethods.setData.call(this, data), flipMethods.resize.call(this, !0)
					}
				},
				_fold: function(point) {
					var px, gradientEndPointA, gradientEndPointB, gradientStartV, gradientSize, gradientOpacity, that = this,
						a = 0,
						alpha = 0,
						mv = point2D(0, 0),
						df = point2D(0, 0),
						tr = point2D(0, 0),
						width = this.width(),
						height = this.height(),
						folding = flipMethods._foldingPage.call(this),
						data = (Math.tan(alpha), this.data().f),
						ac = data.opts.acceleration,
						h = data.wrapper.height(),
						o = flipMethods._c.call(this, point.corner),
						top = "t" == point.corner.substr(0, 1),
						left = "l" == point.corner.substr(1, 1),
						compute = function() {
							var middle, rel = point2D(o.x ? o.x - point.x : point.x, o.y ? o.y - point.y : point.y),
								tan = Math.atan2(rel.y, rel.x);
							alpha = A90 - tan, a = deg(alpha), middle = point2D(left ? width - rel.x / 2 : point.x + rel.x / 2, rel.y / 2);
							var gamma = alpha - Math.atan2(middle.y, middle.x),
								distance = Math.max(0, Math.sin(gamma) * Math.sqrt(Math.pow(middle.x, 2) + Math.pow(middle.y, 2)));
							if(tr = point2D(distance * Math.sin(alpha), distance * Math.cos(alpha)), alpha > A90 && (tr.x = tr.x + Math.abs(tr.y * Math.tan(tan)), tr.y = 0, Math.round(tr.x * Math.tan(PI - alpha)) < height)) return point.y = Math.sqrt(Math.pow(height, 2) + 2 * middle.x * rel.x), top && (point.y = height - point.y), compute();
							if(alpha > A90) {
								var beta = PI - alpha,
									dd = h - height / Math.sin(beta);
								mv = point2D(Math.round(dd * Math.cos(beta)), Math.round(dd * Math.sin(beta))), left && (mv.x = -mv.x), top && (mv.y = -mv.y)
							}
							px = Math.round(tr.y / Math.tan(alpha) + tr.x);
							var side = width - px,
								sideX = side * Math.cos(2 * alpha),
								sideY = side * Math.sin(2 * alpha);
							df = point2D(Math.round(left ? side - sideX : px + sideX), Math.round(top ? sideY : height - sideY)), gradientSize = side * Math.sin(alpha);
							var endingPoint = flipMethods._c2.call(that, point.corner),
								far = Math.sqrt(Math.pow(endingPoint.x - point.x, 2) + Math.pow(endingPoint.y - point.y, 2));
							return gradientOpacity = width > far ? far / width : 1, data.opts.frontGradient && (gradientStartV = gradientSize > 100 ? (gradientSize - 100) / gradientSize : 0, gradientEndPointA = point2D(gradientSize * Math.sin(A90 - alpha) / height * 100, gradientSize * Math.cos(A90 - alpha) / width * 100), top && (gradientEndPointA.y = 100 - gradientEndPointA.y), left && (gradientEndPointA.x = 100 - gradientEndPointA.x)), flipMethods._backGradient.call(that) && (gradientEndPointB = point2D(gradientSize * Math.sin(alpha) / width * 100, gradientSize * Math.cos(alpha) / height * 100), left || (gradientEndPointB.x = 100 - gradientEndPointB.x), top || (gradientEndPointB.y = 100 - gradientEndPointB.y)), tr.x = Math.round(tr.x), tr.y = Math.round(tr.y), !0
						},
						transform = function(tr, c, x, a) {
							var f = ["0", "auto"],
								mvW = (width - h) * x[0] / 100,
								mvH = (height - h) * x[1] / 100,
								v = {
									left: f[c[0]],
									top: f[c[1]],
									right: f[c[2]],
									bottom: f[c[3]]
								},
								aliasingFk = 90 != a && -90 != a ? left ? -1 : 1 : 0;
							x = x[0] + "% " + x[1] + "%", that.css(v).transform(rotate(a) + translate(tr.x + aliasingFk, tr.y, ac), x), data.fpage.parent().css(v), data.wrapper.transform(translate(-tr.x + mvW - aliasingFk, -tr.y + mvH, ac) + rotate(-a), x), data.fwrapper.transform(translate(-tr.x + mv.x + mvW, -tr.y + mv.y + mvH, ac) + rotate(-a), x), data.fpage.parent().transform(rotate(a) + translate(tr.x + df.x - mv.x, tr.y + df.y - mv.y, ac), x), data.opts.frontGradient && gradient(data.ashadow, point2D(left ? 100 : 0, top ? 100 : 0), point2D(gradientEndPointA.x, gradientEndPointA.y), [
								[gradientStartV, "rgba(0,0,0,0)"],
								[.8 * (1 - gradientStartV) + gradientStartV, "rgba(0,0,0," + .2 * gradientOpacity + ")"],
								[1, "rgba(255,255,255," + .2 * gradientOpacity + ")"]
							], 3, alpha), flipMethods._backGradient.call(that) && gradient(data.bshadow, point2D(left ? 0 : 100, top ? 0 : 100), point2D(gradientEndPointB.x, gradientEndPointB.y), [
								[.8, "rgba(0,0,0,0)"],
								[1, "rgba(0,0,0," + .3 * gradientOpacity + ")"],
								[1, "rgba(0,0,0,0)"]
							], 3)
						};
					switch(point.corner) {
						case "tl":
							point.x = Math.max(point.x, 1), compute(), transform(tr, [1, 0, 0, 1], [100, 0], a), data.fpage.transform(translate(-height, -width, ac) + rotate(90 - 2 * a), "100% 100%"), folding.transform(rotate(90) + translate(0, -height, ac), "0% 0%");
							break;
						case "tr":
							point.x = Math.min(point.x, width - 1), compute(), transform(point2D(-tr.x, tr.y), [0, 0, 0, 1], [0, 0], -a), data.fpage.transform(translate(0, -width, ac) + rotate(-90 + 2 * a), "0% 100%"), folding.transform(rotate(270) + translate(-width, 0, ac), "0% 0%");
							break;
						case "bl":
							point.x = Math.max(point.x, 1), compute(), transform(point2D(tr.x, -tr.y), [1, 1, 0, 0], [100, 100], -a), data.fpage.transform(translate(-height, 0, ac) + rotate(-90 + 2 * a), "100% 0%"), folding.transform(rotate(270) + translate(-width, 0, ac), "0% 0%");
							break;
						case "br":
							point.x = Math.min(point.x, width - 1), compute(), transform(point2D(-tr.x, -tr.y), [0, 1, 1, 0], [0, 100], a), data.fpage.transform(rotate(90 - 2 * a), "0% 0%"), folding.transform(rotate(90) + translate(0, -height, ac), "0% 0%")
					}
					data.point = point
				},
				_moveFoldingPage: function(bool) {
					var data = this.data().f,
						folding = flipMethods._foldingPage.call(this);
					folding && (bool ? data.fpage.children()[data.ashadow ? "1" : "0"] || (flipMethods.setData.call(this, {
						backParent: folding.parent()
					}), data.fpage.prepend(folding)) : data.backParent && data.backParent.prepend(folding))
				},
				_showFoldedPage: function(c, animate) {
					var folding = flipMethods._foldingPage.call(this),
						dd = this.data(),
						data = dd.f;
					if(!data.point || data.point.corner != c.corner) {
						var event = $.Event("start");
						if(this.trigger(event, [data.opts, c.corner]), event.isDefaultPrevented()) return !1
					}
					if(folding) {
						if(animate) {
							var that = this,
								point = data.point && data.point.corner == c.corner ? data.point : flipMethods._c.call(this, c.corner, 1);
							this.animatef({
								from: [point.x, point.y],
								to: [c.x, c.y],
								duration: 500,
								frame: function(v) {
									c.x = Math.round(v[0]), c.y = Math.round(v[1]), flipMethods._fold.call(that, c)
								}
							})
						} else flipMethods._fold.call(this, c), dd.effect && !dd.effect.turning && this.animatef(!1);
						return data.fwrapper.is(":visible") || (data.fparent.show().data().flips++, flipMethods._moveFoldingPage.call(this, !0), data.fwrapper.show(), data.bshadow && data.bshadow.show()), !0
					}
					return !1
				},
				hide: function() {
					var data = this.data().f,
						folding = flipMethods._foldingPage.call(this);
					return 0 === --data.fparent.data().flips && data.fparent.hide(), this.css({
						left: 0,
						top: 0,
						right: "auto",
						bottom: "auto"
					}).transform("", "0% 100%"), data.wrapper.transform("", "0% 100%"), data.fwrapper.hide(), data.bshadow && data.bshadow.hide(), folding.transform("", "0% 0%"), this
				},
				hideFoldedPage: function(animate) {
					var data = this.data().f;
					if(data.point) {
						var that = this,
							p1 = data.point,
							hide = function() {
								data.point = null, that.flip("hide"), that.trigger("end", [!1])
							};
						if(animate) {
							var p4 = flipMethods._c.call(this, p1.corner),
								top = "t" == p1.corner.substr(0, 1),
								delta = top ? Math.min(0, p1.y - p4.y) / 2 : Math.max(0, p1.y - p4.y) / 2,
								p2 = point2D(p1.x, p1.y + delta),
								p3 = point2D(p4.x, p4.y - delta);
							this.animatef({
								from: 0,
								to: 1,
								frame: function(v) {
									var np = bezier(p1, p2, p3, p4, v);
									p1.x = np.x, p1.y = np.y, flipMethods._fold.call(that, p1)
								},
								complete: hide,
								duration: 800,
								hiding: !0
							})
						} else this.animatef(!1), hide()
					}
				},
				turnPage: function(corner) {
					var that = this,
						data = this.data().f;
					corner = {
						corner: data.corner ? data.corner.corner : corner || flipMethods._cAllowed.call(this)[0]
					};
					var p1 = data.point || flipMethods._c.call(this, corner.corner, data.opts.turn ? data.opts.turn.data().opts.elevation : 0),
						p4 = flipMethods._c2.call(this, corner.corner);
					this.trigger("flip").animatef({
						from: 0,
						to: 1,
						frame: function(v) {
							var np = bezier(p1, p1, p4, p4, v);
							corner.x = np.x, corner.y = np.y, flipMethods._showFoldedPage.call(that, corner)
						},
						complete: function() {
							that.trigger("end", [!0])
						},
						duration: data.opts.duration,
						turning: !0
					}), data.corner = null
				},
				moving: function() {
					return "effect" in this.data()
				},
				isTurning: function() {
					return this.flip("moving") && this.data().effect.turning
				},
				_eventStart: function(e) {
					var data = this.data().f;
					if(!data.disabled && !this.flip("isTurning")) {
						if(data.corner = flipMethods._cornerActivated.call(this, e), data.corner && flipMethods._foldingPage.call(this, data.corner)) return flipMethods._moveFoldingPage.call(this, !0), this.trigger("pressed", [data.point]), !1;
						data.corner = null
					}
				},
				_eventMove: function(e) {
					var data = this.data().f;
					if(!data.disabled)
						if(e = isTouch ? e.originalEvent.touches : [e], data.corner) {
							var pos = data.parent.offset();
							data.corner.x = e[0].pageX - pos.left, data.corner.y = e[0].pageY - pos.top, flipMethods._showFoldedPage.call(this, data.corner)
						} else if(!this.data().effect && this.is(":visible")) {
						var corner = flipMethods._cornerActivated.call(this, e[0]);
						if(corner) {
							var origin = flipMethods._c.call(this, corner.corner, data.opts.cornerSize / 2);
							corner.x = origin.x, corner.y = origin.y, flipMethods._showFoldedPage.call(this, corner, !0)
						} else flipMethods.hideFoldedPage.call(this, !0)
					}
				},
				_eventEnd: function() {
					var data = this.data().f;
					if(!data.disabled && data.point) {
						var event = $.Event("released");
						this.trigger(event, [data.point]), event.isDefaultPrevented() || flipMethods.hideFoldedPage.call(this, !0)
					}
					data.corner = null
				},
				disable: function(disable) {
					return flipMethods.setData.call(this, {
						disabled: disable
					}), this
				}
			},
			cla = function(that, methods, args) {
				if(args[0] && "object" != typeof args[0]) {
					if(methods[args[0]] && "_" != args[0].toString().substr(0, 1)) return methods[args[0]].apply(that, Array.prototype.slice.call(args, 1));
					throw args[0] + " is an invalid value"
				}
				return methods.init.apply(that, args)
			};
		$.extend($.fn, {
			flip: function() {
				return cla(this, flipMethods, arguments)
			},
			turn: function() {
				return cla(this, turnMethods, arguments)
			},
			transform: function(transform, origin) {
				var properties = {};
				return origin && (properties[vendor + "transform-origin"] = origin), properties[vendor + "transform"] = transform, this.css(properties)
			},
			animatef: function(point) {
				var data = this.data();
				if(data.effect && clearInterval(data.effect.handle), point) {
					point.to.length || (point.to = [point.to]), point.from.length || (point.from = [point.from]), point.easing || (point.easing = function(x, t, b, c, data) {
						return c * Math.sqrt(1 - (t = t / data - 1) * t) + b
					});
					var j, diff = [],
						len = point.to.length,
						that = this,
						fps = point.fps || 30,
						time = -fps,
						f = function() {
							var j, v = [];
							for(time = Math.min(point.duration, time + fps), j = 0; len > j; j++) v.push(point.easing(1, time, point.from[j], diff[j], point.duration));
							point.frame(1 == len ? v[0] : v), time == point.duration && (clearInterval(data.effect.handle), delete data.effect, that.data(data), point.complete && point.complete())
						};
					for(j = 0; len > j; j++) diff.push(point.to[j] - point.from[j]);
					data.effect = point, data.effect.handle = setInterval(f, fps), this.data(data), f()
				} else delete data.effect
			}
		}), $.isTouch = isTouch
	}(jQuery),
	function(window, jq) {
		function checkSize() {
			winWidth = jq(window).width(), winHeight = jq(window).height(), calcByWidth = 1900 / 1084 > winWidth / winHeight, 601 > winHeight && (jq("body").addClass("m"), noAnimate = !0)
		}

		function onResize() {
			checkSize(), 1366 > winWidth ? jq("#a .info-wrap").addClass("info-wrap-sort") : jq("#a .info-wrap").removeClass("info-wrap-sort"), 1e3 > winWidth ? jq("body").width(1e3) : jq("body").css("width", "100%");
			var screenHeight = winHeight - getTopHeight() - getFooterHeight();
			return jq(".screen").height(screenHeight), scrollSize = screenHeight, jq("#fullPage").height(winHeight - getTopHeight()), jq("#scroller").css("top", curIndex * screenHeight * -1), is_mobi && window.location.search.indexOf("mv=fp") < 0 ? void jq("head").append("<link rel='stylesheet' type='text/css' href='css/ie-fixed.css' />") : (resizeA(screenHeight), void resizeObj(screenHeight))
		}

		function resizeA(screenHeight) {
			jq(".ani-wrap").height(screenHeight - jq(".info-wrap").height())
		}

		function resizeObj(screenHeight) {
			for(var _h, w, h, o, objList = jq(".obj"), i = 0; o = objList[i]; i += 1) {
				o = jq(o);
				var ow = o.data("w") || o.attr("width"),
					oh = o.data("h") || o.attr("height");
				if(!isNaN(ow) && !isNaN(oh) && (calcByWidth ? (h = winWidth * oh / ow * (ow / 1900), w = h * ow / oh) : (_h = screenHeight * (oh / 1060), w = _h * ow / oh, h = w * oh / ow), o.width(w).height(h), "iPad" === o.attr("id"))) {
					var book = jq("#booksTurn");
					book.css({
						width: "100%",
						height: "100%"
					});
					try {
						book.turn("size", book.width(), book.height())
					} catch(e) {}
				}
			}
		}

		function onLoad() {
			sideNavFunc(), scrollArrowFun(), onResize(), jq("#booksTurn").turn({
				width: jq("#books").width(),
				height: jq("#books").height(),
				display: "single",
				duration: 1200,
				turnCorners: "bl,br"
			})
		}

		function sideNavFunc() {
			jq(".side-nav-item").each(function() {
				var $sideNav = jq("#sideNav"),
					_self = jq(this),
					index = jq(this).index();
				_self.bind("click", function() {
					scrollTo(index), $sideNav.removeClass("side-nav-0 side-nav-1 side-nav-2 side-nav-3"), $sideNav.addClass("side-nav-" + index), jq("#sideNav .side-nav-item").removeClass("side-nav-item-cur")
				})
			})
		}

		function scrollArrowFun() {
			var $arrowDow = jq(".arrow-down"),
				$arrowUp = jq(".arrow-up");
			$arrowDow.bind("click", function() {
				scrollTo(curIndex + 1)
			}), $arrowUp.bind("click", function() {
				scrollTo(curIndex - 1)
			})
		}

		function onMouseMove(ev) {
			if(!noAnimate) {
				var left = (ev.clientX - .6 * winWidth) / (.6 * winWidth),
					top = (ev.clientY - .6 * winHeight) / (.6 * winWidth),
					elements = jq(".layer");
				elements.each(function() {
					var el = jq(this),
						rate = parseInt(el.data("z")),
						max = 4 * (11 - rate),
						toLeft = left * max,
						toTop = top * max;
					el.css("transform", "translate(" + toLeft + "px, " + toTop + "px)")
				})
			}
		}

		function onScroll(ev) {
			var newTimer = Date.parse(new Date),
				direction = ev.deltaY < 0 ? -1 : 1;
			if(1e3 > newTimer - lastScrollTimer) return !1;
			if(direction > 0 && 0 === curIndex) return !1;
			if(0 > direction && 3 === curIndex) return !1;
			lastScrollTimer = newTimer;
			var toScreen = curIndex - direction;
			return scrollTo(toScreen)
		}

		function scrollTo(targetIndex) {
			if(!(0 > targetIndex && targetIndex > 3)) {
				var distance = targetIndex * scrollSize * -1,
					direction = targetIndex - curIndex > 0 ? -1 : 1;
				onBeforeScroll(direction), jq("#scroller").animate({
					top: distance + "px"
				}, 900, "easeInOutSine", function() {
					curIndex = targetIndex, onAfterScroll(direction)
				})
			}
		}

		function onBeforeScroll() {
			0 === curIndex && jq(".info-wrap").hide(), (0 === curIndex || 3 === curIndex) && jq("#footer").hide(), 2 === curIndex && 2 == jq("#booksTurn").turn("page") && jq("#booksTurn").turn("page", 1), jq(".arrow-down, .arrow-up").hide()
		}

		function onAfterScroll() {
			var curr = parseInt(curIndex),
				$sideNav = jq("#sideNav"),
				$sideNavitem = jq("#sideNav .side-nav-item");
			$sideNavitem.removeClass("side-nav-item-cur"), $sideNav.removeClass("side-nav-0 side-nav-1 side-nav-2 side-nav-3"), $sideNavitem.eq(curr).addClass("side-nav-item-cur"), $sideNav.addClass("side-nav-" + curr), 0 === curIndex ? (jq(".info-wrap").fadeIn(), jq("#fullPage").addClass("show-a")) : jq("#fullPage").removeClass("show-a"), (3 === curIndex || 0 === curIndex) && jq("#footer").fadeIn(), 2 === curIndex && setTimeout(function() {
				jq("#booksTurn").turn("page", 2)
			}, 300), 3 === curIndex && (setTimeout(function() {
				jq("#renwu span").eq(0).addClass("fadeIn")
			}, 200), setTimeout(function() {
				jq("#renwu span").eq(1).addClass("fadeIn")
			}, 800), setTimeout(function() {
				jq("#renwu span").eq(2).addClass("fadeIn")
			}, 1600), setTimeout(function() {
				jq("#renwu span").eq(3).addClass("fadeIn")
			}, 2e3)), 3 !== curIndex && jq(".arrow-down").show(), 0 !== curIndex && jq(".arrow-up").show()
		}

		function getFooterHeight() {
			return jq("#footer").height()
		}

		function getTopHeight() {
			return jq("#header").height()
		}
		var is_mobi = (null != navigator.userAgent.match(/(iPad|iPod|iPhone)/i), null != navigator.userAgent.toLowerCase().match(/(ipod|iphone|android|coolpad|mmp|smartphone|midp|wap|xoom|symbian|j2me|blackberry|win ce)/i)),
			lastScrollTimer = 0,
			winWidth = 0,
			winHeight = 0,
			calcByWidth = !0,
			curIndex = 0,
			scrollSize = 0,
			noAnimate = !1;
		jq(function(jq) {
			jq(window).bind({
				load: onLoad,
				resize: onResize
			}), jq("html").hasClass("pages-html") || (jq(document).bind({
				mousewheel: onScroll
			}), jq("#fullPage").bind({
				mousemove: onMouseMove
			}), jq(".col").bind({
				mouseover: function() {
					jq(this).addClass("hover")
				},
				mouseout: function() {
					jq(this).removeClass("hover")
				}
			}))
		}(jq))
	}(window, jQuery);